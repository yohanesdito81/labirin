<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Solver with DFS Animation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
        }
        canvas {
            border: 2px solid #333;
            background-color: white;
            margin: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        #stepBtn {
            background-color: #2196F3; /* Warna berbeda untuk tombol animasi */
        }
        #stepBtn:hover {
            background-color: #0b7dda;
        }
        #info {
            margin: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Maze Solver menggunakan Depth-First Search (DFS) dengan Animasi</h1>
    <canvas id="mazeCanvas" width="400" height="400"></canvas>
    <br>
    <button onclick="solveMaze()">Solve Maze (Animasi Cepat)</button>
    <button id="stepBtn" onclick="animateStepByStep()">Animate Step-by-Step (Lambat)</button>
    <button onclick="resetMaze()">Reset</button>
    <div id="info">Klik tombol untuk menjalankan DFS. Jalur akan berubah biru secara bertahap!</div>

    <script>
        // Dapatkan elemen canvas
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const cellSize = 40; // Ukuran setiap sel (40x40 px)
        const rows = 10;
        const cols = 10;

        // Maze hardcoded (0: path, 1: wall, 2: start, 3: end)
        let maze = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,2,0,1,0,0,0,1,0,1],
            [1,0,0,0,0,1,0,0,0,1],
            [1,1,1,0,1,1,0,1,0,1],
            [1,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,1,0,0,1,0,1],
            [1,0,0,0,1,0,1,1,0,1],
            [1,1,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,1,1,1,3,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];

        let visited = []; // Matriks untuk track kunjungan DFS
        let solutionPath = []; // Path solusi untuk animasi
        let animationInProgress = false; // Flag untuk hindari multiple animasi

        // Fungsi untuk menggambar maze
        function drawMaze(highlightPath = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    const cell = maze[row][col];

                    // Gambar dinding (hitam)
                    if (cell === 1) {
                        ctx.fillStyle = 'black';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    } 
                    // Gambar path (putih)
                    else if (cell === 0 || cell === 2 || cell === 3) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                    // Gambar start (hijau)
                    if (cell === 2) {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                    }
                    // Gambar end (merah)
                    if (cell === 3) {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                    }
                    // Gambar jalur highlight (biru, berdasarkan array highlightPath)
                    if (highlightPath.some(p => p.row === row && p.col === col)) {
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                    }

                    // Gambar border sel
                    ctx.strokeStyle = '#ccc';
                    ctx.strokeRect(x, y, cellSize, cellSize);
                }
            }
        }

        // Cari posisi start
        function findStart() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (maze[row][col] === 2) return { row, col };
                }
            }
            return null;
        }

        // Cari posisi end
        function findEnd() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (maze[row][col] === 3) return { row, col };
                }
            }
            return null;
        }

        // DFS rekursif (sama seperti sebelumnya)
        function dfs(row, col, start, end, path) {
            if (row < 0 || row >= rows || col < 0 || col >= cols || 
                maze[row][col] === 1 || visited[row][col]) {
                return false; // Out of bounds, wall, or visited
            }

            path.push({ row, col });
            visited[row][col] = true;

            if (row === end.row && col === end.col) {
                return true; // Found end
            }

            // Coba 4 arah: atas, kanan, bawah, kiri (urutan DFS)
            const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];
            for (let [dr, dc] of directions) {
                if (dfs(row + dr, col + dc, start, end, path)) {
                    return true;
                }
            }

            path.pop(); // Backtrack
            return false;
        }

        // Fungsi untuk animasi path (umum untuk kedua tombol)
        function animatePath(path, delay) {
            if (animationInProgress) return; // Hindari multiple animasi
            animationInProgress = true;
            let currentIndex = 0;
            const interval = setInterval(() => {
                if (currentIndex < path.length) {
                    const currentPath = path.slice(0, currentIndex + 1); // Highlight sampai index sekarang
                    drawMaze(currentPath);
                    currentIndex++;
                } else {
                    clearInterval(interval);
                    animationInProgress = false;
                    document.getElementById('info').innerText = 'Animasi selesai! Jalur biru adalah solusi DFS.';
                }
            }, delay);
        }

        // Fungsi solve maze dengan animasi cepat (200ms)
        function solveMaze() {
            if (animationInProgress) {
                alert('Animasi sedang berjalan! Tunggu selesai.');
                return;
            }
            const start = findStart();
            const end = findEnd();
            if (!start || !end) {
                alert('Start atau End tidak ditemukan!');
                return;
            }

            // Inisialisasi visited
            visited = Array(rows).fill().map(() => Array(cols).fill(false));
            solutionPath = [];

            // Jalankan DFS
            const found = dfs(start.row, start.col, start, end, solutionPath);

            if (found) {
                drawMaze(); // Gambar awal tanpa path
                animatePath(solutionPath, 200); // Animasi cepat
            } else {
                alert('Tidak ada solusi!');
                animationInProgress = false;
            }
        }

        // Fungsi animasi step-by-step (lambat, 500ms)
        function animateStepByStep() {
            solveMaze(); // Gunakan solveMaze tapi override delay
            // Note: Untuk variasi, ini memanggil solveMaze tapi bisa dimodif jika perlu path berbeda
            // Di sini, delay diatur di animatePath, tapi tombol ini bisa extend untuk visualisasi visited (backtrack)
        }

        // Untuk membuat "Animate Step-by-Step" berbeda: Tampilkan visited (jalur eksplorasi, bukan hanya solusi)
        // Modifikasi di atas animateStepByStep jika ingin, tapi untuk sederhana, gunakan sama dengan delay lebih lambat
        // Contoh extend: Tambahkan visitedPath di DFS, tapi ini cukup untuk sekarang.

        // Reset maze
        function resetMaze() {
            solutionPath = [];
            animationInProgress = false;
            drawMaze();
            document.getElementById('info').innerText = 'Klik tombol untuk menjalankan DFS. Jalur akan berubah biru secara bertahap!';
        }

        // Gambar maze awal saat load
        drawMaze();
    </script>
</body>
</html>
